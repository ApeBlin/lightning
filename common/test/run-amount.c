#include "config.h"
#include "../amount.c"
#include <common/setup.h>
#include <stdio.h>

/* AUTOGENERATED MOCKS START */
<<<<<<< HEAD
/* Generated stub for fromwire */
const u8 *fromwire(const u8 **cursor UNNEEDED, size_t *max UNNEEDED, void *copy UNNEEDED, size_t n UNNEEDED)
{ fprintf(stderr, "fromwire called!\n"); abort(); }
/* Generated stub for fromwire_bool */
bool fromwire_bool(const u8 **cursor UNNEEDED, size_t *max UNNEEDED)
{ fprintf(stderr, "fromwire_bool called!\n"); abort(); }
/* Generated stub for fromwire_fail */
void *fromwire_fail(const u8 **cursor UNNEEDED, size_t *max UNNEEDED)
{ fprintf(stderr, "fromwire_fail called!\n"); abort(); }
/* Generated stub for fromwire_secp256k1_ecdsa_signature */
void fromwire_secp256k1_ecdsa_signature(const u8 **cursor UNNEEDED, size_t *max UNNEEDED,
					secp256k1_ecdsa_signature *signature UNNEEDED)
{ fprintf(stderr, "fromwire_secp256k1_ecdsa_signature called!\n"); abort(); }
/* Generated stub for fromwire_sha256 */
void fromwire_sha256(const u8 **cursor UNNEEDED, size_t *max UNNEEDED, struct sha256 *sha256 UNNEEDED)
{ fprintf(stderr, "fromwire_sha256 called!\n"); abort(); }
/* Generated stub for fromwire_tal_arrn */
u8 *fromwire_tal_arrn(const tal_t *ctx UNNEEDED,
		       const u8 **cursor UNNEEDED, size_t *max UNNEEDED, size_t num UNNEEDED)
{ fprintf(stderr, "fromwire_tal_arrn called!\n"); abort(); }
/* Generated stub for fromwire_u32 */
u32 fromwire_u32(const u8 **cursor UNNEEDED, size_t *max UNNEEDED)
{ fprintf(stderr, "fromwire_u32 called!\n"); abort(); }
/* Generated stub for fromwire_u64 */
u64 fromwire_u64(const u8 **cursor UNNEEDED, size_t *max UNNEEDED)
{ fprintf(stderr, "fromwire_u64 called!\n"); abort(); }
/* Generated stub for fromwire_u8 */
u8 fromwire_u8(const u8 **cursor UNNEEDED, size_t *max UNNEEDED)
{ fprintf(stderr, "fromwire_u8 called!\n"); abort(); }
/* Generated stub for fromwire_u8_array */
void fromwire_u8_array(const u8 **cursor UNNEEDED, size_t *max UNNEEDED, u8 *arr UNNEEDED, size_t num UNNEEDED)
{ fprintf(stderr, "fromwire_u8_array called!\n"); abort(); }
/* Generated stub for towire */
void towire(u8 **pptr UNNEEDED, const void *data UNNEEDED, size_t len UNNEEDED)
{ fprintf(stderr, "towire called!\n"); abort(); }
/* Generated stub for towire_bool */
void towire_bool(u8 **pptr UNNEEDED, bool v UNNEEDED)
{ fprintf(stderr, "towire_bool called!\n"); abort(); }
/* Generated stub for towire_secp256k1_ecdsa_signature */
void towire_secp256k1_ecdsa_signature(u8 **pptr UNNEEDED,
			      const secp256k1_ecdsa_signature *signature UNNEEDED)
{ fprintf(stderr, "towire_secp256k1_ecdsa_signature called!\n"); abort(); }
/* Generated stub for towire_sha256 */
void towire_sha256(u8 **pptr UNNEEDED, const struct sha256 *sha256 UNNEEDED)
{ fprintf(stderr, "towire_sha256 called!\n"); abort(); }
/* Generated stub for towire_u32 */
void towire_u32(u8 **pptr UNNEEDED, u32 v UNNEEDED)
{ fprintf(stderr, "towire_u32 called!\n"); abort(); }
/* Generated stub for towire_u64 */
void towire_u64(u8 **pptr UNNEEDED, u64 v UNNEEDED)
{ fprintf(stderr, "towire_u64 called!\n"); abort(); }
/* Generated stub for towire_u8 */
void towire_u8(u8 **pptr UNNEEDED, u8 v UNNEEDED)
{ fprintf(stderr, "towire_u8 called!\n"); abort(); }
/* Generated stub for towire_u8_array */
void towire_u8_array(u8 **pptr UNNEEDED, const u8 *arr UNNEEDED, size_t num UNNEEDED)
{ fprintf(stderr, "towire_u8_array called!\n"); abort(); }
=======
>>>>>>> Added a mock test to parse the withdrawal signature request
/* AUTOGENERATED MOCKS END */

#define FAIL_MSAT(msatp, str) \
	assert(!parse_amount_msat((msatp), (str), strlen(str)))
#define PASS_MSAT(msatp, str, val)					\
	do {								\
		assert(parse_amount_msat((msatp), (str), strlen(str))); \
		assert((msatp)->millisatoshis == val);			\
	} while (0)

#define FAIL_SAT(satp, str) \
	assert(!parse_amount_sat((satp), (str), strlen(str)))
#define PASS_SAT(satp, str, val)					\
	do {								\
		assert(parse_amount_sat((satp), (str), strlen(str)));	\
		assert((satp)->satoshis == val);			\
	} while (0)

#include <hsmd/hsmd_wiregen.h>

static bool parse_withdrawal() {
	char *hex = "0007000257e0a09a3e3ef7ee0ebaa4c80737b498e4854e449c782862bf46a60d6c28419500000001000000000000410b0000000000001600145f04366034dcaa5843c0728b2324cade3e288ad301000000000000001503f060953bef5b777dc77e44afa3859d022fc1a77c55138deb232ad7255e869c000000a25c990aafb594afa3cca5f1474941c13960cc60f9dd08abe582c1855e6c04230000000300000000000031270000000000001600142c955bdfeca0ee332e58931b6a3339039600266f01000000000000000b03933884aaf1d6b108397e5efe5c86bcf2d8ca8d2f700eda99db9214fc2712b13400000000058e70736274ff010087020000000257e0a09a3e3ef7ee0ebaa4c80737b498e4854e449c782862bf46a60d6c2841950100000000fdffffffa25c990aafb594afa3cca5f1474941c13960cc60f9dd08abe582c1855e6c04230300000000fdffffff0173710000000000002200205d82155b286f40d498606f3f8b7234ec3f2a35417935d9f74c1e2e28dc305806e0242000000100fd31020200000000010192f6d9b63588899d2bc5dca6ea3196a3cc0f04ed1ef55de40c18b65b07b8b28f0000000000525cc98007993b000000000000220020853fa7f6f1819938e3267cd6c498424425208061fb735d0fcc57d5c18bcf3efe0b410000000000001600145f04366034dcaa5843c0728b2324cade3e288ad3dc7f000000000000220020853fa7f6f1819938e3267cd6c498424425208061fb735d0fcc57d5c18bcf3efe654f010000000000220020853fa7f6f1819938e3267cd6c498424425208061fb735d0fcc57d5c18bcf3efe7a590100000000002200203e26e9b68c0539c3f8820da692ac801754d07560e8e8480912ea8a6b271a0e3b0fd1030000000000220020853fa7f6f1819938e3267cd6c498424425208061fb735d0fcc57d5c18bcf3efe491711000000000022002044de8a66eef3c81b26aa8e61851714fbcf020de994b2468f04943d72ee3152630400473044022042d2134d967bb757e7010ea421e3007fd56b569d3d02bca87da3bf300d87819c02207b7e56bf1a886e0035af9e97f77846345c8f35708fcfa7ec5fb0ccd4c4fa9d1e0148304502210080fd8dffb4fdcf2814c1da62d99b3cbb53c21a28bec7e048edd131b9725e8a070220566ad79296b16bb9d04b9141698cbdb013f6759acebb35cd5d9eaad60e757f6c01475221022a3aee3cd028e390c658de7a1a67a10b6812482ee578e9e791a3c3e31be8a1312103ad3baf178fdf335705a4655e75b6e309973d8f82c55a7ef3c012eace7c83145252aee35b602001011f0b410000000000001600145f04366034dcaa5843c0728b2324cade3e288ad30cfc096c696768746e696e670108dd526210d1542a0a0cfc096c696768746e696e6702020001000100fd300202000000000101071c7894b4697d7a06740614b944e258cb2d514bddfacf47b4e72bfd35484cea000000000049f6048007570300000000000022002034ae3ab3a6f1b8b94c7c23dc92e52202f4374ea73ff06d431f7f9ab6806f59b22a21000000000000220020d4e8f75a7880cbc45a5a84be77664122480e57b05904e706f35d79bfcf6c45068a2e000000000000220020c784a1dbc268d1bf14bd504103ce0e6487750bb22dc1124835429929db205c7627310000000000001600142c955bdfeca0ee332e58931b6a3339039600266f3312020000000000220020d4e8f75a7880cbc45a5a84be77664122480e57b05904e706f35d79bfcf6c45066fc9030000000000220020d4e8f75a7880cbc45a5a84be77664122480e57b05904e706f35d79bfcf6c450618ee0b0000000000220020d4e8f75a7880cbc45a5a84be77664122480e57b05904e706f35d79bfcf6c4506040047304402201621ea9d499cd4f6a04e385914140f861f33be79fdd8ac15a8dcebe5711fc0b302203aaa78b5b9344996eac81333af473856c530f1e53cf99b3017814f37c5b4986c0147304402205b75b9674fb05cbda9e1b8279b822cd79bf5432bf2fc1f072c80a6b4d45bb05d02207e85c04095325e7b1b862535655af609e8544140bf4271dbc25d2ef003bf2f9201475221020fb3c9832ba3986dcb78d4022e7855b80a4cb743ab8a3f2110246e7c96ec06332102cfd5db7ea4c1240ab717160b078d06365b4a25d6b597e0ed9cfa09ac6423b48552ae9486e62001011f27310000000000001600142c955bdfeca0ee332e58931b6a3339039600266f0cfc096c696768746e696e67010848693c960181375e0cfc096c696768746e696e67020200010000";

	struct utxo **utxos;
	struct wally_psbt *psbt;
	u8 *raw = tal_hexdata(NULL, hex, strlen(hex));

	printf("Length %zu\n", tal_bytelen(raw));
	assert(fromwire_hsmd_sign_withdrawal(raw, raw, &utxos, &psbt));
	tal_free(raw);
	return raw != NULL;
}

int main(int argc, char *argv[])
{
	struct amount_msat msat;
	struct amount_sat sat;

	common_setup(argv[0]);

	assert(parse_withdrawal());

	/* Grossly malformed */
	FAIL_MSAT(&msat, "x");
	FAIL_MSAT(&msat, "x100");

	PASS_MSAT(&msat, "0", 0);
	PASS_MSAT(&msat, "1", 1);
	PASS_MSAT(&msat, "2100000000000000000", 2100000000000000000ULL);
	FAIL_MSAT(&msat, "0.0");
	FAIL_MSAT(&msat, "0.00000000");
	FAIL_MSAT(&msat, "0.00000000000");
	FAIL_MSAT(&msat, "0.00000000msat");
	FAIL_MSAT(&msat, "-1");

	PASS_MSAT(&msat, "0msat", 0);
	PASS_MSAT(&msat, "1msat", 1);
	PASS_MSAT(&msat, "2100000000000000000msat", 2100000000000000000ULL);
	FAIL_MSAT(&msat, "-1msat");

	PASS_MSAT(&msat, "0sat", 0);
	PASS_MSAT(&msat, "1sat", 1000);
	PASS_MSAT(&msat, "2100000000000000sat", 2100000000000000000ULL);
	FAIL_MSAT(&msat, "-1sat");

	PASS_MSAT(&msat, "0.00000000btc", 0);
	PASS_MSAT(&msat, "0.00000000000btc", 0);
	PASS_MSAT(&msat, "0.00000001btc", 1000);
	PASS_MSAT(&msat, "0.00000000001btc", 1);
	PASS_MSAT(&msat, "1.2btc", 120000000000);
	PASS_MSAT(&msat, "1.23btc", 123000000000);
	PASS_MSAT(&msat, "1.234btc", 123400000000);
	PASS_MSAT(&msat, "1.2345btc", 123450000000);
	PASS_MSAT(&msat, "1.23456btc", 123456000000);
	PASS_MSAT(&msat, "1.234567btc", 123456700000);
	PASS_MSAT(&msat, "1.2345678btc", 123456780000);
	PASS_MSAT(&msat, "1.23456789btc", 123456789000);
	PASS_MSAT(&msat, "1.234567890btc", 123456789000);
	PASS_MSAT(&msat, "1.2345678901btc", 123456789010);
	PASS_MSAT(&msat, "1.23456789012btc", 123456789012);
	FAIL_MSAT(&msat, "1.000000000000btc");
	FAIL_MSAT(&msat, "-1.23456789btc");
	FAIL_MSAT(&msat, "-1.23456789012btc");

	/* Overflowingly big. */
	FAIL_MSAT(&msat, "21000000000000000000000000.00000000btc");

	/* Grossly malformed */
	FAIL_SAT(&sat, "x");
	FAIL_SAT(&sat, "x100");

	PASS_SAT(&sat, "0", 0);
	PASS_SAT(&sat, "1", 1);
	PASS_SAT(&sat, "2100000000000000", 2100000000000000ULL);
	FAIL_SAT(&sat, "0.0");
	FAIL_SAT(&sat, "0.00000000");
	FAIL_SAT(&sat, "0.00000000000");
	FAIL_SAT(&sat, "0.00000000sat");
	FAIL_SAT(&sat, "0.00000000000msat");
	FAIL_SAT(&sat, "-1");

	PASS_SAT(&sat, "0sat", 0);
	PASS_SAT(&sat, "1sat", 1);
	PASS_SAT(&sat, "2100000000000000sat", 2100000000000000ULL);
	FAIL_SAT(&sat, "-1sat");

	PASS_SAT(&sat, "1000msat", 1);
	PASS_SAT(&sat, "1000000msat", 1000);
	PASS_SAT(&sat, "2100000000000000000msat", 2100000000000000ULL);
	PASS_SAT(&sat, "0msat", 0);
	FAIL_SAT(&sat, "100msat");
	FAIL_SAT(&sat, "2000000000000000999msat");
	FAIL_SAT(&sat, "-1000msat");

	PASS_SAT(&sat, "0.00000000btc", 0);
	FAIL_SAT(&sat, "0.00000000000btc");
	PASS_SAT(&sat, "0.00000001btc", 1);
	FAIL_SAT(&sat, "0.00000000001btc");
	PASS_SAT(&sat, "1.23456789btc", 123456789);
	PASS_SAT(&sat, "1.2btc", 120000000);
	PASS_SAT(&sat, "1.23btc", 123000000);
	PASS_SAT(&sat, "1.234btc", 123400000);
	PASS_SAT(&sat, "1.2345btc", 123450000);
	PASS_SAT(&sat, "1.23456btc", 123456000);
	PASS_SAT(&sat, "1.234567btc", 123456700);
	PASS_SAT(&sat, "1.2345678btc", 123456780);
	PASS_SAT(&sat, "1.23456789btc", 123456789);
	FAIL_SAT(&sat, "1.234567890btc");
	FAIL_SAT(&sat, "-1.23456789btc");

	/* Overflowingly big. */
	FAIL_SAT(&sat, "21000000000000000000000000.00000000btc");

	/* Test fmt_amount_msat_btc, fmt_amount_msat */
	for (u64 i = 0; i <= UINT64_MAX / 10; i = i ? i * 10 : 1) {
		const char *with, *without;

		msat.millisatoshis = i;
		with = fmt_amount_msat_btc(tmpctx, msat, true);
		without = fmt_amount_msat_btc(tmpctx, msat, false);
		assert(strends(with, "btc"));
		assert(strlen(with) == strlen(without) + 3);
		assert(strncmp(with, without, strlen(without)) == 0);
		/* Make sure it overwrites. */
		msat.millisatoshis++;
		assert(parse_amount_msat(&msat, with, strlen(with)));
		assert(msat.millisatoshis == i);

		with = fmt_amount_msat(tmpctx, msat);
		without = tal_fmt(tmpctx, "%"PRIu64, msat.millisatoshis);
		assert(strends(with, "msat"));
		assert(strlen(with) == strlen(without) + 4);
		assert(strncmp(with, without, strlen(without)) == 0);
		/* Make sure it overwrites. */
		msat.millisatoshis++;
		assert(parse_amount_msat(&msat, with, strlen(with)));
		assert(msat.millisatoshis == i);
	}

	/* Test fmt_amount_sat_btc, fmt_amount_sat */
	for (u64 i = 0; i <= UINT64_MAX / 10; i = i ? i * 10 : 1) {
		const char *with, *without;

		sat.satoshis = i;
		with = fmt_amount_sat_btc(tmpctx, sat, true);
		without = fmt_amount_sat_btc(tmpctx, sat, false);
		assert(strends(with, "btc"));
		assert(strlen(with) == strlen(without) + 3);
		assert(strncmp(with, without, strlen(without)) == 0);
		/* Make sure it overwrites. */
		sat.satoshis++;
		assert(parse_amount_sat(&sat, with, strlen(with)));
		assert(sat.satoshis == i);

		with = fmt_amount_sat(tmpctx, sat);
		without = tal_fmt(tmpctx, "%"PRIu64, sat.satoshis);
		assert(strends(with, "sat"));
		assert(strlen(with) == strlen(without) + 3);
		assert(strncmp(with, without, strlen(without)) == 0);
		/* Make sure it overwrites. */
		sat.satoshis++;
		assert(parse_amount_sat(&sat, with, strlen(with)));
		assert(sat.satoshis == i);
	}

	common_shutdown();
}
